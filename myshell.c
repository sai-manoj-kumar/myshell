/* 
 * File:   myshell.c
 * Author: saimanoj
 *
 * Created on 23 October, 2012, 11:20 AM
 */

#include"myshell.h"

struct command supported[] = {
    {"cd", true},
    {"jobs", true},
    {"exit", true},
    {"help", true},
    {"kill", true},
    {"history", true},
    {"ls", false},
    {"ps", false},
    {"pstree", false},
    {"cat", false},
    {"touch", false},
    {"mkdir", false},
    {"rmdir", false},
    {"rm", false},
    {"file", false},
    {"clear", false},
    {"mv", false},
    {"cp", false}
};

void myshell_init() {

    // Initialize the number of processes created by the shell to be zero.
    num_processes = 0;

    // Get the UID of the current user.
    uid = getuid();
    // Get the passwd structure of the current user. 
    // passwd structure is defined in pwd.h, it is included in myshell.h
    current_user = getpwuid(uid);
    // Get the hostname of the computer

    len = 254;

    if (gethostname(host_name, len) == -1) {
        printf("error: myshell: gethostname: can't retrieve hostname\n");
    }

    // Get the username, home directory, details(name, etc.), 
    // default shell, and group id from the passwd structure.
    if (current_user == NULL) {
        printf("NULL\n");
        myshell_exit(1);
    }
    user_name = current_user->pw_name; // Username of the current user
    home_dir = current_user->pw_dir; // Home directory of the current user.
    details = current_user->pw_gecos; // Details of the current user.
    shell = current_user->pw_shell; // Details of the current user.
    gid = current_user->pw_gid; // group id of the current user.

    // Initially, set the current_path as home_dir of the user

    if (-1 == chdir(home_dir)) {
        printf("error: %s\n", strerror(errno));
    }
    strncpy(current_path, home_dir, 256);
    //    strncpy(current_path, "~", 2);

    rl_init();

}

int myshell_exit(int status) {

    // TODO terminate all processes generated by myshell before exiting.
    if (killed_bg_ps) {
        printf("Killed Background Processes\n");
    }
    printf("\nBye, have a nice day.\n");
    exit(status);
}

int rl_init() {
    //    using_history();
}

char* rl_read() {

    static char *line_read = (char *) NULL;
    char shell_prompt[1024];

    /* If the buffer has already been allocated,
     return the memory to the free pool. */
    if (line_read) {
        free(line_read);
        line_read = (char *) NULL;
    }

    snprintf(shell_prompt, sizeof (shell_prompt), "%s@%s:%s > ", user_name, host_name, current_path);

    /* Get a line from the user. */
    line_read = readline(shell_prompt);

    /* If the line has any text in it, and not the last one in the history, 
       save it on the history. */

    HIST_ENTRY ** whole_history;
    int i;

    if (line_read && *line_read) {
        whole_history = history_list();
        if (whole_history) {
            for (i = 0; whole_history[i]; i++);
            if (0 != strcmp(whole_history[i - 1]->line, line_read)) {
                add_history(line_read);
            }
        } else {
            add_history(line_read);
        }
    }

    return (line_read);
}

int validate_input(char input[]) {
    char *pattern1, *pattern2;
    regex_t compiled1, compiled2;
    int result1, result2;

    pattern1 = "^[^|;]\\+\\(\\(|[^|;]\\+\\)\\|\\(;[^|;]\\+\\)\\)\\{0,10\\};\\?$";
    pattern2 = "| \\+|\\|; \\+;\\|; \\+|\\|| \\+;";

    regcomp(&compiled1, pattern1, 0);
    result1 = regexec(&compiled1, input, 0, NULL, 0);
    if (result1 == 0) {
        regcomp(&compiled2, pattern2, 0);
        result2 = regexec(&compiled2, input, 0, NULL, 0);
    }

    if (result1 != 0 || result2 == 0) {
        printf("Error while parsing the command:\nUse pipe(|) and "
                "semicolon(;) at most 10 times and use them legally.\n");
        return -1;
    }
    return 0;
}

int parse_input(char input[], struct component *components) {
    int count = 0, i, j, nspaces = 0;

    for (i = 0, j = 0; input[j] != '\0'; j++) {
        if (i == j && (input[i] == ' ')) {
            i++;
            continue;
        }
        if (input[j] == ';' || input[j] == '|') {
            strncpy(components[count].body, &input[i], j - i - nspaces);
            components[count].body[j - i] = '\0';
            nspaces = 0;
            i = j + 1;
            count++;
        } else if (input[j] == ' ') {
            nspaces++;
        } else {
            nspaces = 0;
        }
    }
    if (i != j) {
        strncpy(components[count].body, &input[i], j - i - nspaces);
        components[count].body[j - i] = '\0';
        count++;
    }

    return count;

}

int myshell_process(struct component *components, int count) {
    int i, j;
    boolean internal = false, external = false;
    char argument[256];
    char args[64][64];
    struct command commands[20];

    for (i = 0; i < count; i++) {
        internal = false;
        external = false;
        printf("^%s$\n", components[i].body);
        sscanf(components[i].body, "%s", commands[i].command);
        //        printf("^%s$\n", commands[i].command);

        for (j = 0; j < 18; j++) {
            if ((0 == strcmp(commands[i].command, supported[j].command)) && supported[j].builtin) {

                internal = true;
                strncpy(argument, &components[i].body[strlen(commands[i].command) + 1], 256);

                int k1, k2;
                for (k1 = 0, k2 = 0; argument[k2] != NULL; k2++) {
                    if (k1 != k2) {
                        argument[k1] = argument[k2];
                        if ('\\' == argument[k1]) {
                            k1++;
                        }
                    }
                    if ('\\' != argument[k2]) {
                        k1++;
                    }
                }
                argument[k1] = NULL;
                break;
            } else if ((0 == strcmp(commands[i].command, supported[j].command)) && !supported[j].builtin) {
                external = true;
                int start = strlen(commands[i].command) + 1;

                int k;
                for (k = 0;; k++) {
                    int n = sscanf(&components[i].body[start], "%s", args[k]);
                    if (1 == n) {
                        printf("%s\n", args[k]);
                    } else if (errno != 0) {
                        perror("scanf");
                    } else {
                        //                        fprintf(stderr, "No matching characters\n");
                        break;
                    }
                    start += strlen(args[k]) + 1;
                    if (k > 10) {
                        printf("Too many arguments to the command %s, Stopping "
                                "Processing command\n", commands[i].command);
                        return -1;
                    }
                }


                break;
            }
        }
        if (internal) {
            call_builtin(supported[j].command, argument);
        } else if (external) {
            //                Spawn a new process.
            myshell_spawn(commands[i].command, args);
        }


    }
    
    
    
    return 0;
}

int call_builtin(char command[], char args[]) {

    if (0 == strcmp(command, "cd")) {
        return cd(args);
    } else if (0 == strcmp(command, "history")) {
        return history(args);
    } else if (0 == strcmp(command, "jobs")) {
        return jobs(args);
    } else if (0 == strcmp(command, "kill")) {
        return kill(args);
    } else if (0 == strcmp(command, "help")) {
        return help();
    } else if (0 == strcmp(command, "exit")) {
        return myshell_exit(EXIT_SUCCESS);
    }

}

void myshell_spawn(char command[], char *args[]) {
    pid_t pid;


    if (strcmp(command, "") != 0) {

        pid = fork();
        //        Add to processes[]
        if (pid == 0) {
            if (execlp(command, "-a", NULL) == -1) {
                printf("%s\n", strerror(errno));
                printf("%s\n", command);
                exit(1);
            }
        }
    }

    wait();

}

int cd(char path[]) {
    char *new_path;
    if ((0 == strcmp(path, "~")) || (0 == strcmp(path, ""))) {
        strncpy(path, current_user->pw_dir, 256);
    }
    if (-1 == chdir(path)) {
        printf("cd: error: %s: %s\n", path, strerror(errno));
        return EXIT_FAILURE;
    } else {
        new_path = getcwd(NULL, 0);
        strcpy(current_path, new_path);
        return EXIT_SUCCESS;
    }
}

int jobs(char args[]) {
    int i;
    //    printf("Jobs\n");
    for (i = 0; i < num_processes; i++) {
        char state[10] = {'h', 'i'};
        printf("[%d] \t %s \t%s\n", i + 1, state, processes[i].command);
    }

    return EXIT_SUCCESS;
}

int kill(char args[]) {
    printf("KILL\n");
    return EXIT_SUCCESS;
}

int history() {

    HIST_ENTRY ** whole_history;
    int i;
    whole_history = history_list();
    if (whole_history) {

        for (i = 0; whole_history[i]; i++) {
            printf("%d : %s\n", i + history_base, whole_history[i]->line);
        }

    }

    return EXIT_SUCCESS;
}

int help() {

    printf("Help\n");

    return EXIT_SUCCESS;
}

