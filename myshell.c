/* 
 * File:   myshell.c
 * Author: saimanoj
 *
 * Created on 23 October, 2012, 11:20 AM
 */

#include"myshell.h"

struct component builtins[] = {"cd", "jobs", "exit", "help", "kill", "history"},
externals[] = {"ls", "ps", "pstree", "cat", "touch", "mkdir",
    "rmdir", "rm", "file", "clear", "mv", "cp"};

void myshell_init() {

    // Get the UID of the current user.
    uid = getuid();
    // Get the passwd structure of the current user. 
    // passwd structure is defined in pwd.h, it is included in myshell.h
    current_user = getpwuid(uid);
    // Get the hostname of the computer

    len = 254;

    if (gethostname(host_name, len) == -1) {
        printf("error: myshell: gethostname: can't retrieve hostname\n");
    }

    // Get the username, home directory, details(name, etc.), 
    // default shell, and group id from the passwd structure.
    if (current_user == NULL) {
        printf("NULL\n");
        myshell_exit(1);
    }
    user_name = current_user->pw_name; // Username of the current user
    home_dir = current_user->pw_dir; // Home directory of the current user.
    details = current_user->pw_gecos; // Details of the current user.
    shell = current_user->pw_shell; // Details of the current user.
    gid = current_user->pw_gid; // group id of the current user.

    // Initially, set the current_path as home_dir of the user
    int c = chdir(home_dir);
    strncpy(current_path, "~", 2);

    rl_init();

}

int myshell_exit(int status) {

    // TODO terminate all processes generated by myshell before exiting.
    if (killed_bg_ps) {
        printf("Killed Background Processes\n");
    }
    printf("\nBye, have a nice day.\n");
    exit(status);
}

int rl_init() {
    // Accepting Defaults for now. No special initializations.    
}

char* rl_read() {

    static char *line_read = (char *) NULL;
    char shell_prompt[1024];

    /* If the buffer has already been allocated,
     return the memory to the free pool. */
    if (line_read) {
        free(line_read);
        line_read = (char *) NULL;
    }

    snprintf(shell_prompt, sizeof (shell_prompt), "%s@%s:%s > ", user_name, host_name, current_path);

    /* Get a line from the user. */
    line_read = readline(shell_prompt);

    /* If the line has any text in it,
       save it on the history. */
    if (line_read && *line_read)
        add_history(line_read);

    return (line_read);
}

int validate(char input[]) {
    char *pattern1, *pattern2;
    regex_t compiled1, compiled2;
    int result1, result2;

    pattern1 = "^[^|;]\\+\\(\\(|[^|;]\\+\\)\\|\\(;[^|;]\\+\\)\\)\\{0,10\\};\\?$";
    pattern2 = "| \\+|\\|; \\+;\\|; \\+|";

    regcomp(&compiled1, pattern1, 0);
    result1 = regexec(&compiled1, input, 0, NULL, 0);
    if (result1 == 0) {
        regcomp(&compiled2, pattern2, 0);
        result2 = regexec(&compiled2, input, 0, NULL, 0);
    }

    if ( result1 != 0 || result2 == 0) {
        printf("Error while parsing the command:\nUse pipe(|) and "
                "semicolon(;) at most 10 times and use them legally.\n");
        return -1;
    }
    return 0;
}

int parse_input(char input[], struct component *components) {
    int count = 0, i, j, nspaces = 0;

    for (i = 0, j = 0; input[j] != '\0'; j++) {
        if (i == j && (input[i] == ';' || input[i] == ' ')) {
            i++;
            continue;
        }
        if (input[j] == ';' || input[j] == '|') {
            strncpy(components[count].body, &input[i], j - i - nspaces);
            components[count].body[j - i] = '\0';
            nspaces = 0;
            i = j + 1;
            count++;
        } else if (input[j] == ' ') {
            nspaces++;
        } else {
            nspaces = 0;
        }
    }
    if (i != j) {
        strncpy(components[count].body, &input[i], j - i - nspaces);
        components[count].body[j - i] = '\0';
        count++;
    }

    return count;

}

int myshell_process(struct component *components){
    
}

void myshell_spawn(char command[]) {
    pid_t pid;


    if (strcmp(command, "") != 0) {

        pid = fork();
        if (pid == 0) {
            if (execlp(command, "-a", NULL) == -1) {
                printf("%s\n", strerror(errno));
                printf("%s\n", command);
                exit(1);
            }
        }
    }

    wait();

}


