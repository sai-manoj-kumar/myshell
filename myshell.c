/* 
 * File:   myshell.c
 * Author: saimanoj
 *
 * Created on 23 October, 2012, 11:20 AM
 */

#include"myshell.h"

struct command supported[] = {
    {"cd", true},
    {"jobs", true},
    {"exit", true},
    {"help", true},
    {"kill", true},
    {"history", true},
    {"clear", true},
    {"ls", false},
    {"ps", false},
    {"pstree", false},
    {"cat", false},
    {"touch", false},
    {"mkdir", false},
    {"rmdir", false},
    {"rm", false},
    {"mv", false},
    {"cp", false}
};

void myshell_init() {

    // Initialize the number of processes created by the shell to be zero.
    num_processes = 0;
    char *env = getenv("PATH");
    if (env == NULL) {
        printf("error: initialize: %s\n", errno);
    }
    // Get the UID of the current user.
    uid = getuid();
    // Get the passwd structure of the current user. 
    // passwd structure is defined in pwd.h, it is included in myshell.h
    current_user = getpwuid(uid);
    // Get the hostname of the computer

    len = 254;

    if (gethostname(host_name, len) == -1) {
        printf("error: myshell: gethostname: can't retrieve hostname\n");
    }

    // Get the username, home directory, details(name, etc.), 
    // default shell, and group id from the passwd structure.
    if (current_user == NULL) {
        printf("NULL\n");
        myshell_exit(1);
    }
    user_name = current_user->pw_name; // Username of the current user
    home_dir = current_user->pw_dir; // Home directory of the current user.
    details = current_user->pw_gecos; // Details of the current user.
    shell = current_user->pw_shell; // Details of the current user.
    gid = current_user->pw_gid; // group id of the current user.

    getcwd(initial_path, 256);
    printf("Initial path %s\n", initial_path);

    // Initially, set the current_path as home_dir of the user. not now.

    //    if (-1 == chdir(home_dir)) {
    //        printf("error: %s\n", strerror(errno));
    //    }
    strncpy(current_path, initial_path, 256);
    char new_env[520];
    strncpy(new_env, current_path, 256);
    strcat(new_env, ":");
    strcat(new_env, env);
    setenv("PATH", new_env, 1);
    //    strncpy(current_path, "~", 2);

    rl_init();

}

int myshell_exit(int status) {

    // TODO terminate all processes generated by myshell before exiting.
    if (killed_bg_ps) {
        printf("Killed Background Processes\n");
    }
    printf("\nBye, have a nice day.\n");
    exit(status);
}

int rl_init() {
    //    using_history();
}

char* rl_read() {

    static char *line_read = (char *) NULL;
    char shell_prompt[1024];

    /* If the buffer has already been allocated,
     return the memory to the free pool. */
    if (line_read) {
        free(line_read);
        line_read = (char *) NULL;
    }

    snprintf(shell_prompt, sizeof (shell_prompt), "%s@%s:%s > ", user_name, host_name, current_path);

    /* Get a line from the user. */
    line_read = readline(shell_prompt);

    /* If the line has any text in it, and not the last one in the history, 
       save it on the history. */

    HIST_ENTRY ** whole_history;
    int i;

    if (line_read && *line_read) {
        whole_history = history_list();
        if (whole_history) {
            for (i = 0; whole_history[i]; i++);
            if (0 != strcmp(whole_history[i - 1]->line, line_read)) {
                add_history(line_read);
            }
        } else {
            add_history(line_read);
        }
    }

    return (line_read);
}

int validate_input(char input[]) {
    char *pattern1, *pattern2;
    regex_t compiled1, compiled2;
    int result1, result2;

    pattern1 = "^[^|;]\\+\\(\\(|[^|;]\\+\\)\\|\\(;[^|;]\\+\\)\\)\\{0,10\\};\\?$";
    pattern2 = "| \\+|\\|; \\+;\\|; \\+|\\|| \\+;";

    regcomp(&compiled1, pattern1, 0);
    result1 = regexec(&compiled1, input, 0, NULL, 0);
    if (result1 == 0) {
        regcomp(&compiled2, pattern2, 0);
        result2 = regexec(&compiled2, input, 0, NULL, 0);
    }

    if (result1 != 0 || result2 == 0) {
        printf("Error while parsing the command:\nUse pipe(|) and "
                "semicolon(;) at most 10 times and use them legally.\n");
        return -1;
    }
    return 0;
}

int parse_input(char input[], struct component *components) {
    int count = 0, i, j, nspaces = 0;

    for (i = 0, j = 0; input[j] != '\0'; j++) {
        if (i == j && (input[i] == ' ')) {
            i++;
            continue;
        }
        if (input[j] == ';' || input[j] == '|') {
            strncpy(components[count].body, &input[i], j - i - nspaces);
            components[count].body[j - i] = '\0';
            nspaces = 0;
            i = j + 1;
            count++;
        } else if (input[j] == ' ') {
            nspaces++;
        } else {
            nspaces = 0;
        }
    }
    if (i != j) {
        strncpy(components[count].body, &input[i], j - i - nspaces);
        components[count].body[j - i] = '\0';
        count++;
    }


    for (i = 0; i < count; i++) {
        char temp[256];
        int k, a;
        for (j = 0, a = 0, k = 0; components[i].body[j] != '\0'; j++) {
            if (components[i].body[j] != ' ') {
                if (j > 0) {
                    if ('\\' == components[i].body[j] && '\\' != components[i].body[j - 1]) {
                        continue;
                        //Unescaping slashes.
                    }
                }
                temp[k] = components[i].body[j];
                k++;
            } else {
                temp[k] = '\0';
                if (components[i].args[a]) {
                    free(components[i].args[a]);
                    components[i].args[a] = (char *) NULL;
                }
                components[i].args[a] = malloc(sizeof (temp));
                strncpy(components[i].args[a], temp, strlen(temp) + 1);
                a++;
                k = 0;
                while (' ' == components[i].body[j + 1])
                    j++;
            }

            if (a > 10) {
                printf("Too many arguments\n");
                return -1;
            }
        }
        temp[k] = '\0';
        if (components[i].args[a]) {
            free(components[i].args[a]);
            components[i].args[a] = (char *) NULL;
        }
        components[i].args[a] = malloc(sizeof (temp));
        strcpy(components[i].args[a], temp);
        a++;
        components[i].args[a] = (char *) NULL;
    }
    return count;

}

int myshell_process(struct component *components, int count) {
    int i, j;
    boolean internal = false, external = false;

    for (i = 0; i < count; i++) {
        internal = false;
        external = false;
        int z;
        for (z = 0; components[i].args[z]; z++) {
            printf("comp %d: arg %d: %s\n", i + 1, z + 1, components[i].args[z]);
        }

        for (j = 0; j < 17; j++) {
            if ((0 == strcmp(components[i].args[0], supported[j].command)) && supported[j].builtin) {
                internal = true;
                break;
            } else if ((0 == strcmp(components[i].args[0], supported[j].command)) && !supported[j].builtin) {
                external = true;
                break;
            }
        }
        if (internal) {
            printf("Builtin\n");
            //            printf("^%s$\n", supported[j].command);
            //            printf("^%s$\n", components[i].args[0]);
            call_builtin(supported[j].command, components[i].args);
        } else if (external) {
            //                Spawn a new process.
            printf("External\n");
            printf("^%s$\n", supported[j].command);
            printf("^%s$\n", components[i].args[0]);
            int re = myshell_spawn(components[i].args);
            if (re != 0) {
                printf("%s exited with %d value\n", components[i].args[0], re);
            }
        } else {
            printf("Not a builtin or external command\n");
            int re = myshell_spawn(components[i].args);
            if (re != 0) {
                printf("%s exited with %d value\n", components[i].args[0], re);
            }

            return -1;
        }

    }

    return 0;
}

int call_builtin(char command[], char *args[]) {

    if (0 == strcmp(command, "cd")) {
        return cd(args);
    } else if (0 == strcmp(command, "history")) {
        return history();
    } else if (0 == strcmp(command, "jobs")) {
        return jobs(args);
    } else if (0 == strcmp(command, "kill")) {
        return kill(args);
    } else if (0 == strcmp(command, "help")) {
        return help();
    } else if (0 == strcmp(command, "exit")) {
        return myshell_exit(EXIT_SUCCESS);
    }

}

int myshell_spawn(char *args[]) {
    pid_t pid;
    int i;
    if (strcmp(args[0], "") != 0) {

        for (i = 0; args[i] != NULL; i++) {
            printf("argument %d  %s\n", i + 1, args[i]);
        }
        pid = fork();
        if (pid == 0) {
            printf("%s\n", args[0]);

            if (execvp(args[0], args) == -1) {
                printf("error: exec: %s %s\n", args[0], strerror(errno));
                printf("%s\n", args[0]);
                exit(1);
            }
        }
        //        Add to processes[]
        processes[num_processes].pid = pid;
        strncpy(processes[num_processes].command, args[0], 50);
        num_processes++;
    }
    int status;
    waitpid(pid, &status, 0);
    num_processes--;
    done[num_done].pid = pid;
    strncpy(done[num_done].command, args[0], 50);
    num_done++;
    return status;
}

int cd(char *args[]) {
    char *new_path;
    char path[256];
    if (args[1] != NULL) {
        strcpy(path, args[1]);
    } else {
        printf("NULL\n");
        strncpy(path, "~", 2);
    }
    if ((0 == strcmp(path, "~")) || (0 == strcmp(path, ""))) {
        strncpy(path, current_user->pw_dir, 256);
    }
    if (-1 == chdir(path)) {
        printf("cd: error: %s: %s\n", path, strerror(errno));
        return EXIT_FAILURE;
    } else {
        new_path = getcwd(NULL, 0);
        strcpy(current_path, new_path);
        return EXIT_SUCCESS;
    }
}

int jobs(char *args[]) {
    int i, j;
    //    printf("Jobs\n");
    for (i = 0; i < num_processes; i++) {
        printf("[%d] \t %s \t%s\n", i + 1, "Running", processes[i].command);
    }
    for (j = 0; j < num_done; j++) {
        printf("[%d] \t %s \t%s\n", j + 1, "Done", done[j].command);
    }
    return EXIT_SUCCESS;
}

int kill(char *args[]) {
    printf("KILL\n");
    return EXIT_SUCCESS;
}

int history() {

    HIST_ENTRY ** whole_history;
    int i;
    whole_history = history_list();
    if (whole_history) {

        for (i = 0; whole_history[i]; i++) {
            printf("%d : %s\n", i + history_base, whole_history[i]->line);
        }

    }

    return EXIT_SUCCESS;
}

int help() {

    printf("Help\n");

    return EXIT_SUCCESS;
}

